---
name: Блоки как объекты
theory: |

  Блоки — одна из ключевых концепций в Ruby, без которой практически не обходится ни один кусок кода. Они очень похожи на обычные лямбда-функции, но имеют свои особые черты. Для хорошего понимания языка и происходящего в коде нужно понимать как они устроены. Здесь мы немного копнем вглубь.

  С одной стороны у блоков есть особый синтаксис создания и передачи в функции как особого параметра.

  ```ruby
  # Открытие файла на запись и добавление туда строки
  File.open('log.txt', 'w') { |f| f.write "[hexlet] #{Time.now} - User logged in\n" }
  ```

  С другой стороны, сам блок это объект как и все остальное в языке. Его можно создать независимо от функции и даже использовать. За блоки в Ruby отвечает класс `Proc`:

  ```ruby
  # Немного взрывает мозг то, что блок определяется через свой же синтаксис
  square = Proc.new { |x| x**2 }
  # альтернативный синтаксис — proc { |x| x**2 }
  square.call(4) # 16
  ```

  С объектом-блоком можно делать все тоже самое что и с другими объектами. В этом смысле, он ведет себя как анонимная функция в любом языке. Однако, если мы захотим этот объект использовать как блок при передачи в функцию, то ничего не получится:

  ```ruby
  [1, 2].map square
  # ArgumentError (wrong number of arguments (given 1, expected 0))
  ```

  Хотя мы и имеем дело с блоком, все же в примере выше он передается в функцию как обычный объект первым параметром. Но метод `map()` не принимает на вход ничего кроме блока, поэтому код завершается с ошибкой. Блок созданный как объект невозможно напрямую использовать в методах ожидающих на вход блоки. Для этого нужен специальный синтаксис:

  ```ruby
  [1, 2].map &square # [1, 4]
  ```

  Амперсанд добавленный в начале переменной содержащей блок, передает этот блок в функцию не как параметр, а как блок. Но тут нас ждет сюрприз:

  ```ruby
  # Завершится с ошибкой
  [1, 2].map() &square

  # Сработает
  [1, 2].map(&square)
  ```

  Это поведение не должно вас вводить в заблуждение. Выше мы видим исключительно особенности синтаксиса. Блок выше не передается как параметр, это легко увидеть если посмотреть на определение метода `map()`. Он не принимает на вход никаких параметров.

instructions: |

  Реализуйте функцию `apply_blocks(data, blocks)`, которая принимает на вход данные и массив блоков. Эта функция должна по цепочке вызывать блоки перадавая туда результат предыдущего вызова блока:

  ```ruby
  proc1 = proc { |x| x + 1 }
  proc2 = proc { |x| x * 2 }

  apply_blocks(5, [proc1, proc2]) # 12
  # proc2.call(proc1.call(5))
  apply_blocks(5, [proc2, proc1]) # 11
  # proc1.call(proc2.call(5))
  ```

tips: []
