---

name: Пайплайн
theory: |

  Функции высшего порядка — это основной способ обработки коллекций во многих языках. И Ruby здесь не исключение. Идиоматический код на Ruby выглядит, как цепочка методов, преобразующих коллекцию в какой-то нужный выход. Такая обработка строится на базе методов `map()`, `filter()`, `reduce()` и их более специфичных аналогах.

  Краткий обзор:

  ```ruby
  # Обходит коллекцию и вызывает для каждого элемента блок
  # Результат складывает в новую коллекцию, которая возвращается
  [1, 2, 3].map { |v| v ** 2 } # [1, 4, 9]

  # Фильтрует коллекцию от элементов не удовлетворяющих условию
  [1, 2, 3].filter { |v| v.odd? } # [1, 3]

  # Обходит коллекцию, накапливая в процессе аккумулятор (acc)
  # После обработки каждого элемента возврат из блока становится
  # новым аккумулятором. В конце он возвращается наружу
  # Начальное значение аккумулятора передается первым аргументом
  [1, 2, 3].reduce(0) { |acc, v| acc + v } # 6
  ```

  При таком подходе вся обработка разбивается на множество небольших действий, которые комбинируются друг с другом, превращаясь в цепочку. Фактически это функциональное программирование на объектах. Оно популярно в большинстве современных языков, поэтому здесь не разбирается подробно.

  Рассмотрим несколько примеров разных преобразований, которые можно выполнять с помощью этих функций с данными, приближенными к реальным.

  ```ruby
  users = [
    { name: 'Bronn', gender: 'male', birthday: '1973-03-23' },
    { name: 'Reigar', gender: 'male', birthday: '1973-11-03' },
    { name: 'Tisha', gender: 'female', birthday: '2012-11-03' },
    { name: 'Sansa', gender: 'female', birthday: '2012-11-03' },
    { name: 'Rick', gender: 'male', birthday: '2012-11-03' },
  ]

  # Формируем список пользователей младше 30 лет
  users.filter { |u| Time.now.year - Time.new(u[:birthday]).year < 30 }

  # Формируем список тех же пользователей, но без gender
  # Обратите внимание на двойные фигурные скобки —
  # внешние для блока, внутренние для хеша
  users.map { |u| { name: u[:name], birthday: u[:birthday] } }

  # Группируем пользователей по полу
  # Аналогичного результата можно добиться с помощью group_by
  users.reduce({}) do |acc, u|
    acc[u[:gender]] ||= []
    acc[u[:gender]] << u
    acc # обязательно вернуть новый acc
  end
  ```

instructions: |

  Реализуйте функцию `get_men_count_by_year()`, которая принимает список пользователей и возвращает объект, где ключ – это год рождения, а значение – это количество мужчин, родившихся в этот год.

  ```ruby
  users = [
    { name: 'Bronn', gender: 'male', birthday: '1973-03-23' },
    { name: 'Reigar', gender: 'male', birthday: '1973-11-03' },
    { name: 'Eiegon', gender: 'male', birthday: '1963-11-03' },
    { name: 'Sansa', gender: 'female', birthday: '2012-11-03' },
    { name: 'Jon', gender: 'male', birthday: '1980-11-03' },
    { name: 'Robb', gender: 'male', birthday: '1980-05-14' },
    { name: 'Tisha', gender: 'female', birthday: '2012-11-03' },
    { name: 'Rick', gender: 'male', birthday: '2012-11-03' },
    { name: 'Joffrey', gender: 'male', birthday: '1999-11-03' },
    { name: 'Edd', gender: 'male', birthday: '1973-11-03' }
  ]

  get_men_count_by_year(users)
  # {
  #   '1973' => 3,
  #   '1963' => 1,
  #   '1980' => 2,
  #   '2012' => 3,
  #   '1999' => 1
  # }
  ```

tips: []
