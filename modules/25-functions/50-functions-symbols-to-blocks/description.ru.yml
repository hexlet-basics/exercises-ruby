---
name: Трансляция символов в блоки
theory: |

  В Ruby-коде можно встретить странную конструкцию из амперсанда, соединенного с символом:

  ```ruby
  ['hexlet', 'code-basics'].map(&:upcase) # ["HEXLET", "CODE-BASICS"]
  # То же самое
  # ['hexlet', 'code-basics'].map { |name| name.upcase }
  ```

  Амперсанд в этом выражении обозначает передачу блока в функцию. Но символ — это не блок. Как работает такой код? Всё дело в приведении типов. У символов определен метод `to_proc()`, который преобразует символ в блок определенного вида. Он вызывается автоматически в тех случаях, когда данные используются как блоки. Это то же самое, что и интерполяция данных в строку.

  В отличие от простых типов данных, преобразование симола в блок работает не очевидно. Проще показать на примере:

  ```ruby
  block = :capitalize.to_proc
  # proc = { |value| value.capitalize }
  block.call('hexlet') # "Hexlet"
  ```

  То есть получившийся блок принимает на вход один параметр, у которого затем вызывается метод с именем исходного символа. Такое преобразование не случайно, его создали как раз для удобной работы с функциями высшего порядка:

  ```ruby
  ['hexlet', 'code-basics'].map(&:reverse).map(&:capitalize)
  # ["Telxeh", "Scisab-edoc"]
  ```

  Этот трюк работает даже для операторов, так как в Ruby большинство операторов всего лишь методы:

  ```ruby
  [1, 3, 4].reduce &:+ # 8
  ```

instructions: |

  Реализуйте функцию `convert()`, которая принимает на вход список строк, и применяет к нему следующую цепочку действий:

  * Список сортируется
  * Фильтрация: удаляются строки, не заканчивающиеся на `'?'`
  * Отображение: все строки приводятся к нижнему регистру

  Результат возвращается наружу:

  ```ruby
  strings = ['wow?', 'One?', 'tWo!', 'THREE']
  convert(strings) # ["one?", "wow?"]
  ```

tips: []
