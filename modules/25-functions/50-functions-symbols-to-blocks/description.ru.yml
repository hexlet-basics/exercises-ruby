---
name: Трансляция символов в блоки
theory: |

  В Ruby коде, часто, можно увидеть странную конструкцию из амперсанда соединного с символом:

  ```ruby
  ['hexlet', 'code-basics'].map(&:upcase) # ["HEXLET", "CODE-BASICS"]
  # Тоже самое
  # ['hexlet', 'code-basics'].map { |name| name.upcase }
  ```

  Амперсанд, в этом выражении, обозначает передачу блока в функцию. Но символ это не блок. Как работает такой код? Все дело в приведении типов. У символов определен метод `to_proc()`, который преобразует символ в блок определенного вида. Он вызывается автоматически в тех случаях, когда данные используются как блоки. Это, примерно, тоже самое, что и интерполяция данных в строку.

  В отличии от простых типов данных, преобразование симола в блок работает не очевидно. Проще показать на примере:

  ```ruby
  block = :capitalize.to_proc
  # proc = { |value| value.capitalize }
  block.call('hexlet') # "Hexlet"
  ```

  То есть получившийся блок принимает на вход один параметр, у которого затем вызывается метод с именем исходного символа. Такое преобразования не случайно, его создали как раз для удобной работы с функциями высшего порядка:

  ```ruby
  ['hexlet', 'code-basics'].map(&:reverse).map(&:capitalize)
  # ["Telxeh", "Scisab-edoc"]
  ```

  Этот трюк работает даже для операторов, так как в руби большинство операторов всего лишь методы:

  ```ruby
  [1, 3, 4].reduce &:+ # 8
  ```

instructions: |

  Реализуйте функцию, которая принимает на вход список строк и применяет к нему следующую цепочку действий:

  * Список сортируется
  * Фильтрация: удаляются строки не заканчивающиеся на `'?'`
  * Отображение: все строки приводятся к нижнему регистру

  Результат возвращается наружу:

  ```ruby
  strings = ['wow?', 'One?', 'tWo!', 'THREE']
  convert(strings) # ["one?", "wow?"]
  ```

tips: []
