---
name: Блоки внутри функции
theory: |

  Написать в Ruby функцию, которая принимает блок, не так страшно, как может показаться на первый взгляд. В самом простом случае нужно знать про одно ключевое слово – `yield`. Именно с его помощью происходит вызов блока:

  ```ruby
  def foo()
    yield
  end

  # Передача блока, который не принимает аргументов
  foo { puts 'code-basics for the brave' }
  # => "code-basics for the brave"
  ```

  Как видно из примера выше, мы не управляем блоком явно. `yield` автоматически получает доступ к блоку и вызывает его. Количество вызовов `yield` может быть любым. Каждый вызов работает, как независимый вызов блока:

  ```ruby
  def foo()
    yield
    yield
  end
  ```

  Если упрощенно, то `yield` можно воспринимать как вызов функции (то есть блока). Например, если блок возвращает результат, то его же вернет и `yield`.

  ```ruby
  def foo()
    yield
  end

  # Передача блока, который не принимает аргументов
  result = foo { 'code-basics for the brave' }
  #  "code-basics for the brave"
  ```

  Если блок содержит параметры, то они передаются в блок через `yield`, как через вызов функции:

  ```ruby
  def foo(value)
    yield(value)
  end

  # Параметр переходит в блок
  foo('Hexlet') { |v| puts v }
  # => "Hexlet"
  ```

  И, собирая все вместе, так выглядит реализация `map()` внутри:

  ```ruby
  def my_map(coll)
    result = []
    coll.each do |elem|
      result << yield(elem)
    end
    result
  end
  ```

instructions: |

  Реализуйте функцию `my_filter()`, которая умеет фильтровать переданную на вход коллекцию по условию в блоке:

  ```ruby
  coll = [1, 2, 3]
  my_filter(coll, &:even?) # [2]
  my_filter(coll, &:odd?) # [1, 3]
  ```

tips: []
