---

name: Лямбда функции
theory: |
  В этом уроке мы познакомимся с анонимными функциями или как их еще называют лямбда-функциями, узнаем их основное отличии от `Proc` и научимся передавать их в другие функции в качестве аргумента и возвращать как результат.

  Лямбда функции лежат в основе лямбда исчислений которые были разработаны математиком Алонзо Чёрчем, именно от туда эта концепция и пришла в программирование.

  Лямбда функция – это анонимная функция или callback-функция, которую определяют в том месте где она используется. В Ruby лямбда функцию можно сохранить в переменную и затем вызвать с помощью метода `call()`:

  ```ruby
  my_lambda = -> { puts 'Hello, World!' }
  my_lambda.call # => Hello, World!
  ```

  Еще лямбда функция является разновидностью `Proc` объектов, но имеет некоторые особенности, давайте посмотрим какие:

  ```ruby
  my_lambda = -> (name) { "Hello, #{name}" }
  my_proc = proc { |name| "Hello, #{name}" }
  puts my_lambda.class # => Proc
  my_proc.call # Hello, nil
  my_lambda.call
  # wrong number of arguments (given 0, expected 1) (ArgumentError)
  ```

  То есть мы видим, что, если не передать аргумент в `Proc`, он подменит его значение на nil, а лямбда выбросит исключение `Argument Error`.

  Лямбда функции и проки по-разному обрабатывают оператор return. При использовании оператора `return` `proc` прервет и свое выполнение, и выполнение метода который его использует.

  ```ruby
  def method_with_lambda
    proc {
      puts 'in lambda'
      return
    }.call
    puts 'in method'
  end
  ```

  Видно, что второй `puts()` не сработал:

  <pre class='hexlet-basics-output'>
  in lambda
  </pre>


  Лямбда-функция входит сама, но родительский метод не прерывает:

  ```ruby
  def method_with_lambda
    lambda {
      puts 'in lambda'
      return
    }.call
    puts 'in method'
  end

  method_with_lambda
  ```

  Мы видим что сработали оба `puts()`. В примере выше ламбда-функция определена в многострочном варианте:

  <pre class='hexlet-basics-output'>
  in lambda
  in method
  </pre>

  Еще одна отличительная особенность `Proc` и лямбда-функций от методов, в области видимости. Посмотрите на пример:

  ```ruby
  name = 'John'

  my_lambda = -> { puts name }
  my_proc = proc { puts name }

  def my_method
    puts name
  end

  my_lambda.call # => John
  my_proc.call # => John
  my_method # => undefined local variable or method 'name'
  ```

  То есть метод не видит переменные определённые на верхнем уровне, их ему надо передать явно.

  В Ruby лямбда-функции - это объекты первого рода, то есть их можно передавать в метод в качестве аргументов:

  ```ruby
  my_lambda = -> (name) { puts "Hello #{name}" }

  def greeating(f)
    f.call('John')
  end

  greeting(my_lambda) # => Hello John
  ```

  И возвращать из метода в качестве результата. Это может быть полезно для захвата лексического окружения:

  ```ruby
  def sum(a)
    -> (b) {a + b}
  end

  partial_sum = sum(2)
  puts partial_sum.call(2) # => 4
  ```

  Мы видим, что метод уже отработал, но лямбда-функция запомнила – замкнула его переменные и к ним можно обратиться.

  Лямбда-функции довольно часто используются в Ruby и Ruby on Rails. Например, в Ruby on Rails для хитрых выборок из базы данных.

  Это код модели из приложения на Ruby on Rails:

  ```ruby
  class User < ApplicationRecord
    scope :young, -> { where("age < 18") }
  end
  ```

  Теперь в приложении мы можем написать `User.young` вместо `User.where("age < 18")` и такой запрос вернет нам всех пользователей моложе 18 - это может существенно сократить код.

  И так в этом уроке мы узнали, что такое лямбда функции, их основном отличии и научились их предавать и возвращать из методов.

instructions: |
  В этом задании мы плотно поработаем с лямбдами и с имитируем работу оператора if используя только функции.

  Напишите метод if_logic – этот метод будет имитировать работу оператор if, и две лямбда-функции: TRUE_LOGIC - имитирует истину, FALSE_LOGIC – имитирует лож.

  Пример использования:

  ```ruby
 
  TRUE_LOGIC = -> () { ... # код функции }
  FALSE_LOGIC = -> () { ... # код функции }

  def if_logic(f)
    # код метода
  end

  if_logic(TRUE_LOGIC).call('one').call('two') # one
  if_logic(FALSE_LOGIC).call('one').call('two') # two
  ```

  То есть мы видим, что в зависимости от переданной лямбды возвращается либо первое, либо второе значение.

  Подсказка: Лямбда может вернуть лямбду!

tips: []
