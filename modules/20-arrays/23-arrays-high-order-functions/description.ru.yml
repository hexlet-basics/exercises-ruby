---
name: Функции высшего порядка
theory: |

  Помимо обычных методов, массивы содержат большое число функций (методов) высшего порядка. Это методы, которые принимают на вход блоки с дополнительной логикой. Возьмем для примера метод `sort()`. Он умеет сортировать только на основе сравнения значений. Такая сортировка сработает в случае простых массивов из чисел, но окажется бесполезной в большинстве реальных ситуаций, где процесс сортировки может быть хитрым. Пример:

  ```ruby
  # Население стран
  data = [
    ['russia', 140_000],
    ['usa', 300_000],
    ['ukraine', 40_000]
  ]
  ```

  Как отсортировать страны по количеству жителей в них? Для таких ситуаций и нужны функции высшего порядка:

  ```ruby
  # Внутрь передается блок, который принимает на вход элемент массива
  data.sort_by { |row| row[1] }
  # [
  #   ['ukraine', 40_000],
  #   ['russia', 140_000],
  #   ['usa', 300_000]
  # ]

  # Либо, если кода много
  data.sort_by do |row|
    row[1]
  end
  ```

  Метод `sort_by()` ожидает, что из блока вернется значение по которому нужно выполнить сортировку. Затем, когда значения собраны, этот метод выполняет сортировку сравнивая значения с помощью оператора `<=>`.

  Вот некоторые примеры:

  * [max_by()](https://ruby-doc.org/core-3.0.0/Enumerable.html#method-i-max_by) – поиск максимального по указанному параметру
  * [find()](https://ruby-doc.org/core-3.0.0/Enumerable.html#method-i-find) – находит элемент по указанному условию
  * [partition()](https://ruby-doc.org/core-3.0.0/Enumerable.html#method-i-partion) – разделяет массив на два по указанному условию

  Практически каждый метод массива работает в двух режимах. Если не передать блок, то метод работает по какому-то простому алгоритму, если блок передан, то он используется как условие для работы метода.

instructions: |

  В разработке

tips: []
