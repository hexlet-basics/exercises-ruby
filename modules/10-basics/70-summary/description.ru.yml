---

name: Особенности языка
theory: |

  Ruby мощный скриптовый язык программирования, который создавался с целью сделать программирование максимально "человечным". В этом языке очень много идиоматики, то есть принципов о том как делать те или иные штуки правильно и в стиле Ruby Way. Это очень похоже на Python с его Pythonic, но Ruby Way местами идет в противоположную сторону. В этом месте программисты делятся на два лагеря. Одним Ruby Way приходится по душе, другие же его не принимают.

  Ruby создавался таким, чтобы одну и ту же задачу можно было сделать большим количеством способов. Например у многих методов существуют алиасы, которые не добавляют новой функциональности, они просто существуют для логичности (стройности) языка. Пример из Rails: `1.day + 5.days`. У обоих операндов вызывается один и тот же метод, но у него разные названия для того чтобы можно было легко прочесть написанное.

  Ruby, благодаря лаконичному синтаксису с минимум шума и наличию блоков, позволяет создавать DSL буквально под каждую задачу, чем программисты с удовольствием пользуются. Это одна из причин почему язык стал популярен в DevOps среде, где было создано множество инструментов написанных на Ruby (Chef, Puppet и другие).

  ```ruby
  # Вроде бы просто роутинг, но он не выглядит как код
  Rails.application.routes.draw do
    root to: "pages#main"

    resources :posts do
      get :preview

      resources :comments, only: [:new, :create, :destroy]
    end
  end
  ```

  Именно в экосистеме Ruby была распространена концепция [соглашения вместо конфигурации](https://en.wikipedia.org/wiki/Convention_over_configuration), которая затем расползлась на все платформы. Это значит вместо конфигурации есть договоренности о том что где лежит, как называется и как работает. Тогда нам не нужно ничего дополнительно описывать. Это большая часть экосистемы, которая распространяется на все библиотеки и проекты.

instructions: |

  В мире существует множество разных билетов, на транспорт, в кино, в театр и так далее. И, как правило, у каждого билета есть свой индивидуальный номер. Считается, что билет счастливый если сумма цифр входящих в этот билет до середины, равна сумме цифр после середины этого числа. Например если номер билета *723428*, то нам нужно сложить *7 + 2 + 3* и сравнить это с *4 + 2 + 8*. Данный билет счастливым не является.

  Напишите функцию, которая определяет счастливый ли перед нами билет. Функция должна работать только с числом, состоящим из четного количества цифр:

  ```ruby
  happy?(77) # true
  happy?(7881) # false
  happy?(732930) # true
  ```

  Алгоритм функции достаточно простой. Нужно превратить число в строку, поделить пополам (можно взять подстроку) и пройтись по каждой половине считая сумму цифр. Для подсчета лучше написать отдельную функцию, чтобы не дублировать эту логику.

  Для решения этой задачи вам могут понадобится:

  * `to_s()` – метод конвертации в строку
  * `to_i()` – метод конвертации в число
  * [each_char()](https://ruby-doc.org/core-2.7.2/String.html#method-i-each_char) – обход строки побуквенно

tips: []
