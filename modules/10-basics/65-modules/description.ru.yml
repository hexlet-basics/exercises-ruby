---
name: Модули
theory: |

  Одна из главных концепций в любом языке – разбиение кода на независимые модули с локальным именованием. В разных языках это делается разными словами, но похожими механизмами, такими как неймспейсы, пакеты, модули.

  В Ruby для этого используется система модулей. Функции, определенные внутри модуля, локальны относительно этого модуля. То есть разные модули могут иметь внутри функции с одинаковыми именами.

  ```ruby
  # file: module_name.rb
  module MyModule
    def self.run
      'go!'
    end
  end
  ```

  При определении функции внутри модуля, к ней нужно добавлять префикс `self.`, только в этом случае получится ее вызвать напрямую из модуля. Без `self.` функции тоже объявляют, но только тогда, когда модуль играет роль миксина. Это очень интересная концепция, которая все чаще встречается в других языках. Подробнее о ней в соответствующем разделе.

  ```ruby
  MyModule.run # 'go!'
  ```

  Вызов функции из модуля выглядит абсолютно идентично вызову методов из класса. Является ли модуль классом? Это легко проверить:

  ```ruby
  MyModule.new # undefined method `new' for MyModule:Module
  # При этом модуль это объект
  MyModule.class # Module
  ```

  Как понять что перед нами класс, а не модуль? Короткий ответ: никак. Обычно это не проблема, потому что из контекста понятно, с чем идет работа. В Ruby-мире много соглашений по тому, как работают библиотеки и как организуется код. Благодаря этому резко упрощается понимание происходящего.

  Встроенных в Ruby модулей не так много. Из наиболее простого можно назвать Math, в котором лежат разные полезные математические функции:

  ```ruby
  # Можно обращаться напрямую, встроенные модули всегда загружены
  Math.sin(1)
  ```

  Из наиболее используемых — модуль Kernel. С его помощью управляют поведением процесса и интерпретатора.

  ```ruby
  Kernel.exit
  ```

  Особенность этого модуля в том, что все функции модуля Kernel доступны для вызова напрямую, без указания имени модуля. Это происходит за счет того, что модуль Kernel "подмешан" в класс Object, от которого наследуются практически все классы в Руби (неявно).

  Если смотреть дальше, то возникает множество вопросов и разных интересных ситуаций: вложенные модули, модули вложенные в классы, классы вложенные в модули и даже классы вложенные в классы. Все это возможно в Ruby. А как соотносятся файловая система и модули? А можно ли определять классы без модулей? А можно ли вызывать функции модуля из функций модуля? К сожалению, не представляется возможным разобрать все эти вопросы в рамках нашего материала. За дальнейшими подробностями добро пожаловать на Хекслет!

instructions: |

  Создайте модуль `MyNumber`. Реализуйте внутри модуля функцию `reverse_int()`, которая переворачивает цифры в переданном числе (типа Integer) и возвращает новое число.

  ```ruby
  reverse_int(13) # 31
  reverse_int(-123) # -321
  reverse_int(8900) # 98
  ```

  Полезные методы:

  * `abs()` – возвращает модуль числа
  * `to_s()` – преобразование в строку
  * `to_i()` – преобразование в число
  * `reverse()` – переворачивает строку


tips: []
